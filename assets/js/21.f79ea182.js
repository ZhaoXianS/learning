(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{424:function(_,v,t){"use strict";t.r(v);var r=t(2),s=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("# 学习目标：")]),_._v(" "),v("ul",[v("li",[_._v("[ ] 设计模式")])]),_._v(" "),v("hr"),_._v(" "),v("h1",{attrs:{id:"学习内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#学习内容"}},[_._v("#")]),_._v(" 学习内容：")]),_._v(" "),v("h3",{attrs:{id:"_1-代码设计的重要性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-代码设计的重要性"}},[_._v("#")]),_._v(" 1.代码设计的重要性")]),_._v(" "),v("p",[_._v("当我们遇到一个与业务无关的功能模块的开发任务时，面对这样的一个稍复杂的代码的设计\n和开发任务时我们经常会感到无从下手，这时就体现出了代码设计的重要性。")]),_._v(" "),v("h3",{attrs:{id:"_2-代码设计原则-先有问题-后有方案。不要脱离具体的场景谈代码设计。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-代码设计原则-先有问题-后有方案。不要脱离具体的场景谈代码设计。"}},[_._v("#")]),_._v(" 2.代码设计原则：先有问题，后有方案。不要脱离具体的场景谈代码设计。")]),_._v(" "),v("h3",{attrs:{id:"_3-面向对象分析、面向对象设计、面向对象编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-面向对象分析、面向对象设计、面向对象编程"}},[_._v("#")]),_._v(" 3.面向对象分析、面向对象设计、面向对象编程")]),_._v(" "),v("p",[_._v("面向对象设计步骤：")]),_._v(" "),v("p",[_._v("（1）划分职责进而识别有哪些类：①进行模块划分②拆解成功能点列表")]),_._v(" "),v("p",[_._v("（2）定义类及其属性和方法")]),_._v(" "),v("p",[_._v("（3）定义类之间的交互关系：①泛化②实现③组合")]),_._v(" "),v("p",[_._v("（4）将类组装起来并提供执行入口")]),_._v(" "),v("h3",{attrs:{id:"_4-基于-贫血-模型的传统开发模式和基于-充血-模型的ddd-领域驱动设计-开发模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-基于-贫血-模型的传统开发模式和基于-充血-模型的ddd-领域驱动设计-开发模式"}},[_._v("#")]),_._v(" 4.基于“贫血”模型的传统开发模式和基于“充血”模型的DDD（领域驱动设计）开发模式")]),_._v(" "),v("p",[v("strong",[_._v("“贫血”模型")]),_._v("将数据与操作分离，破换了面向对象编程的封装特性，属于典型的面向过程编程风格。")]),_._v(" "),v("p",[_._v("例如：UserBo只含数据，UserService只含业务，两者都在service层。")]),_._v(" "),v("p",[v("strong",[_._v("“充血”模型")]),_._v("的DDD开发，service层包含Service和Domain，Domain类既包含数据又包含业务。")]),_._v(" "),v("p",[_._v("基于“贫血”模型的传统开发模式，重Service类，轻BO类；基于“充血”模型的DDD开发模式轻Service，中Domain类。")]),_._v(" "),v("h3",{attrs:{id:"_5-抽象类侧重代码复用-接口侧重解耦-接口定义一种协议或者契约。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-抽象类侧重代码复用-接口侧重解耦-接口定义一种协议或者契约。"}},[_._v("#")]),_._v(" 5.抽象类侧重代码复用，接口侧重解耦，接口定义一种协议或者契约。")]),_._v(" "),v("h3",{attrs:{id:"_6-基于接口而非实现类编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-基于接口而非实现类编程"}},[_._v("#")]),_._v(" 6.基于接口而非实现类编程")]),_._v(" "),v("h3",{attrs:{id:"_7-组合优于继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-组合优于继承"}},[_._v("#")]),_._v(" 7.组合优于继承")]),_._v(" "),v("h3",{attrs:{id:"_8-设计原则-具体细节参考书籍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-设计原则-具体细节参考书籍"}},[_._v("#")]),_._v(" 8.设计原则（具体细节参考书籍）")]),_._v(" "),v("p",[_._v("单一职责原则：一个类或模块只负责完成一个职责。")]),_._v(" "),v("p",[v("strong",[_._v("开闭原则(看源码)")]),_._v("：对扩展开放，对修改关闭。")]),_._v(" "),v("p",[_._v("里氏替换原则：子类对象能够替换到程序中父类对象出现的任何地方，并且保证程序原有的逻辑行为布标和正确性不被破坏。")]),_._v(" "),v("p",[_._v("接口隔离原则：客户端不应该被强迫依赖它不需要的接口。")]),_._v(" "),v("p",[_._v("依赖反转原则：实体必须依靠抽象而不是具体实现。它表示高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象。")]),_._v(" "),v("p",[_._v("KISS（尽量保持简单）原则和YAGNI（不要设计当前用不到的功能，）原则，KISS原则讲的是如何做，YAGNI原则讲的是要不要做。")]),_._v(" "),v("p",[_._v("DRY（不要编写重复的代码）原则，LOD（最少知道原则）原则。")]),_._v(" "),v("h3",{attrs:{id:"_9-代码规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-代码规范"}},[_._v("#")]),_._v(" 9.代码规范")]),_._v(" "),v("p",[_._v("（1）模块化思维，善于将大块的复杂业务的代码封装成类或函数。")]),_._v(" "),v("p",[_._v("（2）当参数超过5个时，尽量封装成类。")]),_._v(" "),v("p",[_._v("（3）减少嵌套层数，将部分嵌套代码封装成函数。")]),_._v(" "),v("h3",{attrs:{id:"_10-重构技巧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-重构技巧"}},[_._v("#")]),_._v(" 10.重构技巧")]),_._v(" "),v("p",[_._v("1."),v("strong",[_._v("小型重构")]),_._v("主要是针对类、函数和变量等级别的重构，如规范命名、规范注释、消除超大类或函数、提取重复代码，所以说小的重构随时都可以进行。")]),_._v(" "),v("p",[_._v("2."),v("strong",[_._v("大型重构")]),_._v("中保证重构不出错的有效手段就是编写单元测试")]),_._v(" "),v("p",[_._v("3.编写可测试的代码")]),_._v(" "),v("p",[_._v("4.解耦的方法：")]),_._v(" "),v("p",[_._v("（1）通过封装与抽象进行解耦")]),_._v(" "),v("p",[_._v("（2）引入中间层")]),_._v(" "),v("p",[_._v("（3）模块化")]),_._v(" "),v("p",[_._v("（4）利用代码设计思想和设计原则")]),_._v(" "),v("p",[_._v("5.当函数抛出异常时，我们应该选择哪种方式")]),_._v(" "),v("p",[_._v("异常是否抛给上层调用函数，取决于上层函数是否与发生的异常有相关性，是否封装成新的异常抛给上层函数取决于上层调用函数能不能处理这个异常。")]),_._v(" "),v("h3",{attrs:{id:"_11-创建型设计模式-具体细节参考书籍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-创建型设计模式-具体细节参考书籍"}},[_._v("#")]),_._v(" 11.创建型设计模式（具体细节参考书籍）")]),_._v(" "),v("p",[v("strong",[_._v("单例模式")])]),_._v(" "),v("p",[_._v("如果某个类并没有拓展的需求，并且不依赖外部系统，那么，为了限制其对象的全局唯一性，将其设计出成单例就是合理的，"),v("strong",[_._v("spring注入的对象就是单例实现的。")])]),_._v(" "),v("p",[_._v("‘饿汉’式：线程安全，不支持延迟加载。")]),_._v(" "),v("p",[_._v("‘懒汉’式：支持延迟加载。")]),_._v(" "),v("p",[_._v("双重检测")]),_._v(" "),v("p",[_._v("静态内部类")]),_._v(" "),v("p",[_._v("枚举：保证了实例创建的线程安全性和实例的唯一性。")]),_._v(" "),v("p",[v("strong",[_._v("工厂模式")])]),_._v(" "),v("p",[_._v("简单工厂模式")]),_._v(" "),v("p",[_._v("工厂方法模式")]),_._v(" "),v("p",[_._v("抽象工厂模式")]),_._v(" "),v("p",[v("strong",[_._v("应用：Spring依赖注入")])]),_._v(" "),v("p",[_._v("建造者模式:‘定制化’创建不同的对象")]),_._v(" "),v("p",[_._v("原型模式：利用已有对象（原型）进行复制（拷贝）的方式进行创建对象。")]),_._v(" "),v("h3",{attrs:{id:"_12-结构型设计模式-具体细节参考书籍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-结构型设计模式-具体细节参考书籍"}},[_._v("#")]),_._v(" 12.结构型设计模式（具体细节参考书籍）")]),_._v(" "),v("p",[v("strong",[_._v("代理模式（看源码）")]),_._v("：在不改变原始类的情况下，通过引入代理类来给原始类附加"),v("strong",[_._v("不相关的其他功能")]),_._v("。")]),_._v(" "),v("p",[_._v("应用："),v("strong",[_._v("SpringAOP、日志")]),_._v("、幂等、事物、鉴权、监控、统计、限流、RPC（远程代理）、缓存中的应用。")]),_._v(" "),v("p",[v("strong",[_._v("装饰器模式")]),_._v("：用组合代替继承，给原始类添加了"),v("strong",[_._v("相关的其他功能")]),_._v("。")]),_._v(" "),v("p",[_._v("适配器模式")]),_._v(" "),v("p",[v("strong",[_._v("应用：SLF4J对不同的日志框架的接口进行二次封装，适配成统一的SLF4J接口定义。")])]),_._v(" "),v("p",[_._v("桥接模式：组合代替继承，将MxN的继承关系变成M+N的组合关系")]),_._v(" "),v("p",[_._v("门面模式：为子系统定义一组统一的接口")]),_._v(" "),v("p",[_._v("组合模式：")]),_._v(" "),v("p",[_._v("享元模式：对"),v("strong",[_._v("不可变对象")]),_._v("进行共享，但对JVM的“垃圾”回收并不友好，谨慎使用")]),_._v(" "),v("h3",{attrs:{id:"_13-行为型设计模式-具体细节参考书籍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-行为型设计模式-具体细节参考书籍"}},[_._v("#")]),_._v(" 13.行为型设计模式（具体细节参考书籍）")]),_._v(" "),v("p",[v("strong",[_._v("观察者模式")]),_._v("（发布/订阅模式）")]),_._v(" "),v("p",[v("strong",[_._v("同步阻塞")]),_._v("的观察者模式主要是为了代码解耦；"),v("strong",[_._v("异步非阻塞")]),_._v("的观察者模式除了能够实现代码解耦外，还能够提高代码的执行效率；"),v("strong",[_._v("跨进程")]),_._v("的观察者模式一般基于消息队列，其解耦更加彻底，用来实现不通进程间的被观察者和观察者的交互。")]),_._v(" "),v("p",[v("strong",[_._v("模板方法模式")]),_._v("：在一个方法中定义一个算法框架，并将某些步骤推迟到子类中实现")]),_._v(" "),v("p",[_._v("作用："),v("strong",[_._v("复用")]),_._v("和"),v("strong",[_._v("扩展")])]),_._v(" "),v("p",[v("strong",[_._v("回调")]),_._v("：同步回调指在函数返回之前执行回调函数，异步回调是指在函数返回之后执行回调函数，同步回调看起来像模板方法模式，异步回调看起来像观察者模式。"),v("strong",[_._v("回调比模板方法模式更加灵活。")])]),_._v(" "),v("p",[v("strong",[_._v("策略模式")]),_._v("：定义一组算法，将每个算法分别封装，让他们可以互相替换。")]),_._v(" "),v("p",[_._v("策略模式的主要作用是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不太复杂。")]),_._v(" "),v("p",[_._v("应用：支付方式、电商网站活动。")]),_._v(" "),v("p",[_._v("职责链模式：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求；将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。")]),_._v(" "),v("p",[_._v("应用：拦截器、过滤器。")]),_._v(" "),v("p",[_._v("状态模式")]),_._v(" "),v("p",[_._v("迭代器模式")]),_._v(" "),v("p",[_._v("访问者模式")]),_._v(" "),v("p",[_._v("备忘录模式")]),_._v(" "),v("p",[_._v("命令模式")]),_._v(" "),v("p",[_._v("解释器模式")]),_._v(" "),v("p",[_._v("中介模式")])])}),[],!1,null,null,null);v.default=s.exports}}]);