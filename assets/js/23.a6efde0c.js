(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{427:function(a,_,t){"use strict";t.r(_);var v=t(2),s=Object(v.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("p",[a._v("# 学习目标：")]),a._v(" "),_("ul",[_("li",[a._v("[ ] 深入理解Java核心技术（基础篇）")])]),a._v(" "),_("hr"),a._v(" "),_("h1",{attrs:{id:"学习内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#学习内容"}},[a._v("#")]),a._v(" 学习内容：")]),a._v(" "),_("h3",{attrs:{id:"_1-面向对象的五大基本原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-面向对象的五大基本原则"}},[a._v("#")]),a._v(" 1.面向对象的五大基本原则")]),a._v(" "),_("p",[a._v("（1）"),_("strong",[a._v("单一职责原则")]),a._v("：一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。")]),a._v(" "),_("p",[a._v("（2）"),_("strong",[a._v("开放封闭原则")]),a._v("：对象或实体应该对扩展开放，对修改封。")]),a._v(" "),_("p",[a._v("（3）"),_("strong",[a._v("里氏替换原则")]),a._v("：在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（即对父类的调用同样适用于子类）")]),a._v(" "),_("p",[a._v("（4）"),_("strong",[a._v("接口隔离原则")]),a._v("：不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法。")]),a._v(" "),_("p",[a._v("（5）"),_("strong",[a._v("依赖反转原则")]),a._v("：实体必须依靠抽象而不是具体实现。它表示高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象。")]),a._v(" "),_("h3",{attrs:{id:"_2-多态-同一操作作用于不同的对象-可以有不同的解释-产生不同的执行结果。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-多态-同一操作作用于不同的对象-可以有不同的解释-产生不同的执行结果。"}},[a._v("#")]),a._v(" 2.多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。")]),a._v(" "),_("h3",{attrs:{id:"_3-继承与实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-继承与实现"}},[a._v("#")]),a._v(" 3. 继承与实现")]),a._v(" "),_("p",[a._v("（1）继承的根本原因是因为要复用，而实现的根本原因是定义一个标准。")]),a._v(" "),_("p",[a._v("（2）多继承会出现菱形继承问题，C++引入虚继承解决。")]),a._v(" "),_("p",[a._v("（3）"),_("strong",[a._v("组合与继承")]),a._v("：继承是is-a的关系，组合是has-a的关系。同样可行的情况下建议用组合。")]),a._v(" "),_("h3",{attrs:{id:"_4-在定义一个boolean类型的javabean时-应该使用success而不是issuccess。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-在定义一个boolean类型的javabean时-应该使用success而不是issuccess。"}},[a._v("#")]),a._v(" 4.在定义一个Boolean类型的JavaBean时，应该使用success而不是isSuccess。")]),a._v(" "),_("h3",{attrs:{id:"_5-equals和hashcode的关系-equals和-的关系。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-equals和hashcode的关系-equals和-的关系。"}},[a._v("#")]),a._v(" 5. equals和hashCode的关系，equals和==的关系。")]),a._v(" "),_("p",[a._v("在没有重写equals方法的情况下，使用equals做比较，判断的是两个对象的引用是否相等。如果想判断两个对象的内容是否相等，则需要重写equals和hashCode方法。")]),a._v(" "),_("p",[a._v("在java中，==比较的是对象的"),_("strong",[a._v("引用")]),a._v("，而equals比较的是"),_("strong",[a._v("值")]),a._v("。")]),a._v(" "),_("h3",{attrs:{id:"_6-clone方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-clone方法"}},[a._v("#")]),a._v(" 6.clone方法")]),a._v(" "),_("p",[a._v("clone方法在不重写的情况下是"),_("strong",[a._v("浅拷贝")]),a._v("，想要实现"),_("strong",[a._v("深拷贝")]),a._v("需要重写clone方法，还有一种实现深拷贝的方式是序列化技术")]),a._v(" "),_("h3",{attrs:{id:"_7-java是值传递-只不过把对象的引用当作值传递给方法-共享对象传递"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-java是值传递-只不过把对象的引用当作值传递给方法-共享对象传递"}},[a._v("#")]),a._v(" 7.java是值传递，只不过把对象的引用当作值传递给方法（共享对象传递）")]),a._v(" "),_("h3",{attrs:{id:"_8-基本数据类型直接在栈内存中存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-基本数据类型直接在栈内存中存储"}},[a._v("#")]),a._v(" 8.基本数据类型直接在栈内存中存储")]),a._v(" "),_("h3",{attrs:{id:"_9-用bigdecimal或者long来表示金额"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-用bigdecimal或者long来表示金额"}},[a._v("#")]),a._v(" 9.用BigDecimal或者Long来表示金额")]),a._v(" "),_("h3",{attrs:{id:"_10-字符串的不可变性-主要从缓存、安全性、线程安全和性能等方面进行考虑的。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-字符串的不可变性-主要从缓存、安全性、线程安全和性能等方面进行考虑的。"}},[a._v("#")]),a._v(" 10.字符串的不可变性：主要从缓存、安全性、线程安全和性能等方面进行考虑的。")]),a._v(" "),_("h3",{attrs:{id:"_11-string对-的重载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-string对-的重载"}},[a._v("#")]),a._v(" 11.String对'+'的重载")]),a._v(" "),_("p",[a._v("拼接过程中是将String转换成StringBuilder后，使用其append方法进行处理的。")]),a._v(" "),_("h3",{attrs:{id:"_12-常用的字符串拼接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-常用的字符串拼接"}},[a._v("#")]),a._v(" 12.常用的字符串拼接")]),a._v(" "),_("p",[a._v("有五种，"),_("strong",[a._v("分别是'+'、concat、StringBuilder、StringBuffer和StringUtils.join")]),a._v("。")]),a._v(" "),_("p",[a._v("如果不是在循环体中进行字符串的拼接用'+'。")]),a._v(" "),_("p",[a._v("如果在并发中使用字符串拼接则要使用StringBuffer代替StringBuilder。")]),a._v(" "),_("p",[a._v("如果是通过一个List进行字符串拼接，则使用StringJoiner（java8中提供的StringJoiner，与Stream流有关）。")]),a._v(" "),_("h3",{attrs:{id:"_13-从字符串中删除空格"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-从字符串中删除空格"}},[a._v("#")]),a._v(" 13.从字符串中删除空格")]),a._v(" "),_("p",[a._v("java11中的"),_("strong",[a._v("strip()方法")]),a._v("要比"),_("strong",[a._v("trim()方法")]),a._v("更强大，它可以删除很多不在ASCLL中的空白字符，但是删除的是字符串前导和末尾的空格。")]),a._v(" "),_("p",[a._v("**replaceAll()**与适当的正则表达式一起使用可以删除字符串中的空格。")]),a._v(" "),_("h3",{attrs:{id:"_14-switch的使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-switch的使用"}},[a._v("#")]),a._v(" 14.switch的使用")]),a._v(" "),_("p",[_("strong",[a._v("switch只能使用整型")]),a._v("，比如byte、short、char和int,其它数据类型都是转成整型之后再使用switch的。")]),a._v(" "),_("h3",{attrs:{id:"_15-类加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-类加载"}},[a._v("#")]),a._v(" 15.类加载")]),a._v(" "),_("p",[a._v("类加载的过程要经历加载、链接、初始化等几个步骤，在链接的步骤中又分为验证、准备和解析。")]),a._v(" "),_("h3",{attrs:{id:"_16-异常处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-异常处理"}},[a._v("#")]),a._v(" 16.异常处理")]),a._v(" "),_("p",[a._v("自己明确知道如何处理的，就要处理，不知道如何处理的，就要向上抛出，交给调用者处理。")]),a._v(" "),_("p",[a._v("try是必须的，catch和finally至少有一个。")]),a._v(" "),_("p",[_("strong",[a._v("finally是在什么时候执行的")]),a._v("？")]),a._v(" "),_("p",[a._v("如果try中有return，先执行finally再执行try中的return，如果try和finally中都有return，则finally中的return最后执行。")]),a._v(" "),_("h3",{attrs:{id:"_17-集合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-集合"}},[a._v("#")]),a._v(" 17.集合")]),a._v(" "),_("p",[a._v("（1）集合的遍历："),_("strong",[a._v("for、foreach、迭代器Iterator、迭代器Enumeration、Stream流")])]),a._v(" "),_("p",[a._v("（2）ArrayList 的扩容是之前的1.5倍，Vector扩容是之前的2倍，vector是线程安全的。")]),a._v(" "),_("p",[a._v("（3）Collections的synchronizedList方法可以把任意一个List转换成一个线程安全的List。")]),a._v(" "),_("p",[a._v("（4）"),_("strong",[a._v("synchronizedList和Vector建议使用synchronizedList")]),a._v("。因为可以定义一个线程安全的LinkList。")]),a._v(" "),_("p",[a._v("（5）HashMap最多允许存储一个null键和多个null值，然而TreeMap不允许空键，但可能有多个空值。")]),a._v(" "),_("p",[a._v("（6）HashTable是线程安全的，但是在普通和get方法上都增加了synchronized，因此有了concurrentHashMap，在1.7之前使用分段（segment）锁，1.8之后改为node结点锁，锁粒度更小。")]),a._v(" "),_("p",[a._v("（7）同步容器（Vector和HashTable）中复合方法也不是线程安全的。")]),a._v(" "),_("p",[a._v("（8）HashMap扩容是之前的2倍，扩容时还要进行rehash，初始化容量要设成expectedSize/0.75+1,而且将hash()方法生成的整型值转换成数组下标时"),_("strong",[a._v("使用位运算代替取模")]),a._v("增加效率（还能解决负数的问题），HashMap运用扰动降低Hash冲突,，")]),a._v(" "),_("p",[a._v("（9）HashTable 默认的初始大小是11，每次扩充2n+1，")]),a._v(" "),_("h3",{attrs:{id:"_18-在foreach循环中对某些集合中的元素进行remove-add操作-会导致concurrentmodificationexception。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_18-在foreach循环中对某些集合中的元素进行remove-add操作-会导致concurrentmodificationexception。"}},[a._v("#")]),a._v(" 18.在foreach循环中对某些集合中的元素进行remove/add操作，会导致ConcurrentModificationException。")]),a._v(" "),_("h3",{attrs:{id:"_19-stream流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_19-stream流"}},[a._v("#")]),a._v(" 19.Stream流")]),a._v(" "),_("p",[a._v("Stream的创建：（1）通过已有的集合创建流：集合.stream()（2）通过Stream.of()创建流")]),a._v(" "),_("p",[a._v("Stream的中间操作：filter、map、limit、sorted、distinct。")]),a._v(" "),_("p",[a._v("Stream的最终操作：forEach、count、collect。")]),a._v(" "),_("h3",{attrs:{id:"_20-反射"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_20-反射"}},[a._v("#")]),a._v(" 20.反射")]),a._v(" "),_("p",[a._v("通过以下三种方式可以获取一个class对象")]),a._v(" "),_("p",[a._v("（1）调用对象的getClass()方法获取Class对象")]),a._v(" "),_("p",[a._v("（2）根据类名.class获取Class对象")]),a._v(" "),_("p",[a._v("（3）根据Class中的静态方法Class.forName()获取Class对象")]),a._v(" "),_("p",[a._v("反射破坏了单例模式，序列化也可以破坏单例模式")]),a._v(" "),_("h3",{attrs:{id:"_21-序列化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_21-序列化"}},[a._v("#")]),a._v(" 21.序列化")]),a._v(" "),_("p",[a._v("我们创建的java对象都是存在于JVM的堆内存中（不考虑JIT优化）的。")]),a._v(" "),_("p",[a._v("序列化是将对象装换为可存储或传输的形式的过程，一般是以字节码或XML格式传输对象的。而将字节码或XML编码格式的对象还原为对象的过程称为反序列化。")]),a._v(" "),_("p",[a._v("序列化会通过反射调用无参的构造方法创建一个新的对象进而破坏单例模式。")]),a._v(" "),_("h3",{attrs:{id:"_22-枚举"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_22-枚举"}},[a._v("#")]),a._v(" 22.枚举")]),a._v(" "),_("p",[a._v("使用枚举可以实现单例模式，且是线程安全的。")]),a._v(" "),_("h3",{attrs:{id:"_23-i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_23-i-o"}},[a._v("#")]),a._v(" 23.I/O")]),a._v(" "),_("p",[a._v("输入流：inputStream（字节流）和Reader（字符流）")]),a._v(" "),_("p",[a._v("输出流：OutputStream（字节流）和Write（字符流）")]),a._v(" "),_("p",[a._v("OutputStreamWrite是Write的子类，是字符流通向字节流的桥梁")]),a._v(" "),_("p",[a._v("InputStreamReader是Reader的子类，是字节流通向字符流的桥梁")]),a._v(" "),_("p",[_("strong",[a._v("阻塞和非阻塞")]),a._v("描述的是调用方，"),_("strong",[a._v("同步和异步")]),a._v("描述的是被调用方。")]),a._v(" "),_("p",[a._v("Linux的五种I/O模型：阻塞I/O、非阻塞I/O、I/O复用模型、信号驱动式I/O和异步I/O模型。")]),a._v(" "),_("p",[_("strong",[a._v("BIO（同步阻塞）、NIO（同步非阻塞）、AIO（异步非阻塞）")])]),a._v(" "),_("h3",{attrs:{id:"_24-动态代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_24-动态代理"}},[a._v("#")]),a._v(" 24.动态代理")]),a._v(" "),_("p",[a._v("动态代理的几种实现方式：JDK动态代理、CGLib动态代理。")]),a._v(" "),_("p",[a._v("实现动态代理主要涉及哪几个类："),_("strong",[a._v("Proxy")]),a._v("（生成代理的主类）和"),_("strong",[a._v("InvocationHandler")]),a._v("（调用处理器）")]),a._v(" "),_("h3",{attrs:{id:"_25-注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_25-注解"}},[a._v("#")]),a._v(" 25.注解")]),a._v(" "),_("p",[a._v("注解分为元注解和自定义注解")]),a._v(" "),_("p",[a._v("日常开发中常用注解：")]),a._v(" "),_("p",[a._v("（1）使用自自定义注解做日志记录")]),a._v(" "),_("p",[a._v("（2）使用自定义注解做前置检查")]),a._v(" "),_("p",[a._v("编程式事物和声明式事物")]),a._v(" "),_("h3",{attrs:{id:"_26-泛型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_26-泛型"}},[a._v("#")]),a._v(" 26.泛型")]),a._v(" "),_("p",[a._v("泛型不支持基本数据类型")]),a._v(" "),_("p",[a._v("如何使用 <? extends T>和<? super T>")]),a._v(" "),_("h3",{attrs:{id:"_27-时间处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_27-时间处理"}},[a._v("#")]),a._v(" 27.时间处理")]),a._v(" "),_("p",[a._v("SimpleDateFormat是线程不安全的类，一般不要定义为static变量，也不要当成共享变量使用。")]),a._v(" "),_("p",[a._v("SimpleDateFormat中format将一个Date类型转换为String，parse方法将一个String转换为Date类型。")]),a._v(" "),_("p",[a._v("Java8中的时间处理：LocalTime和LocalDate")]),a._v(" "),_("p",[_("strong",[a._v("日期格式要用y表示年，而不能用Y（涉及跨年时间段的问题）。")])]),a._v(" "),_("h3",{attrs:{id:"_28-语法糖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_28-语法糖"}},[a._v("#")]),a._v(" 28.语法糖")]),a._v(" "),_("p",[a._v("语法糖让程序更加简单，有更高的可读性。")]),a._v(" "),_("h3",{attrs:{id:"_29-bigdecimal"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_29-bigdecimal"}},[a._v("#")]),a._v(" 29.BigDecimal")]),a._v(" "),_("p",[a._v("使用BigDecimal(double)创建一个BigDecimal是损失了精度的，要使用BigDecimal(String)创建BigDecimal。")]),a._v(" "),_("p",[a._v("BigDecimal的等值比较使用compareTo()方法，而不是equals()方法。")]),a._v(" "),_("h3",{attrs:{id:"_30-java工具库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_30-java工具库"}},[a._v("#")]),a._v(" 30.Java工具库")]),a._v(" "),_("p",[_("strong",[a._v("Apache Commons")])]),a._v(" "),_("p",[a._v("常用的有BeanUtils、Collections、IO、Long、Logging和OGNL")]),a._v(" "),_("p",[a._v("Commons Long中提供很多好用的工具类：StringUtils、ArrayUtils、DateUtils。")]),a._v(" "),_("p",[a._v("Commons IO中常用的有：IOUtils、FileUtils、FilenameUtils。")]),a._v(" "),_("p",[a._v("Commons BeanUtils中有：BeanUtils和propertyUtils，BeanUtils在进行属性拷贝时本质上是浅拷贝")]),a._v(" "),_("p",[a._v("MapStruct字段映射工具")]),a._v(" "),_("p",[_("strong",[a._v("Guava")])]),a._v(" "),_("p",[a._v("常用的有：Optional、Guava Cache")]),a._v(" "),_("p",[_("strong",[a._v("Lombok")])]),a._v(" "),_("h3",{attrs:{id:"_31-java新版本特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_31-java新版本特性"}},[a._v("#")]),a._v(" 31.Java新版本特性")]),a._v(" "),_("p",[a._v("java8：函数式编程，有且只有一个抽象方法的接口被称为函数式接口，函数式接口适用于函数式编程的场景。")]),a._v(" "),_("p",[a._v("java9：模块化技术")]),a._v(" "),_("p",[a._v("java10：本地变量类型推断")]),a._v(" "),_("p",[a._v("java11：增强var")]),a._v(" "),_("p",[a._v("java12：Switch表达式")]),a._v(" "),_("p",[a._v("java13：text block")]),a._v(" "),_("p",[a._v("java14：更有价值的NullPointException、record类型")]),a._v(" "),_("p",[a._v("java15：封闭类")]),a._v(" "),_("p",[a._v("java16：instanceof模式匹配")]),a._v(" "),_("p",[a._v("java17：Switch模式匹配")])])}),[],!1,null,null,null);_.default=s.exports}}]);