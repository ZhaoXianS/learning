(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{426:function(_,v,t){"use strict";t.r(v);var s=t(2),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("# 学习目标：")]),_._v(" "),v("ul",[v("li",[_._v("[ ] 深入浅出Mysql")])]),_._v(" "),v("hr"),_._v(" "),v("h1",{attrs:{id:"学习内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#学习内容"}},[_._v("#")]),_._v(" 学习内容：")]),_._v(" "),v("h3",{attrs:{id:"_1-myisam和innodb对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-myisam和innodb对比"}},[_._v("#")]),_._v(" 1. MyISAM和InnoDB对比")]),_._v(" "),v("p",[_._v("MyISAM是Mysql5.5之前版本的默认存储引擎，既不支持事物，也不支持外键。MyISAM的数据文件和索引文件可以放置在不同的目录，平均分配IO，获得更快的速度。")]),_._v(" "),v("p",[_._v("InnoDB作为Mysql5.5之后的默认存储引擎，提供了具有提交、回滚和崩溃恢复能力的"),v("strong",[_._v("事物")]),_._v("安全保障，同时提供了更小的锁粒度（"),v("strong",[_._v("行级锁")]),_._v("）和更强的并发能力、支持"),v("strong",[_._v("外键约束")]),_._v("，拥有自己独立的缓存和日志。但是会占用磁盘空间以保留数据和索引。")]),_._v(" "),v("h3",{attrs:{id:"_2-索引的使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-索引的使用"}},[_._v("#")]),_._v(" 2. 索引的使用")]),_._v(" "),v("h4",{attrs:{id:"innodb使用b-tree作为索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb使用b-tree作为索引"}},[_._v("#")]),_._v(" InnoDB使用B+TREE作为索引")]),_._v(" "),v("p",[_._v("1.B+树非叶子几点不存储数据，所以每一层能够存储的索引数量会增加，意味着B+树在层高相同的情况下存储的数据量要比B树要更多，使得"),v("strong",[_._v("磁盘IO次数更少")]),_._v("。")]),_._v(" "),v("p",[_._v("2.Mysql中，"),v("strong",[_._v("范围查询")]),_._v("是一个比较常用的操作，而B+树的所有存储在叶子节点的数据使用了双向链表来关联，所以查询的时候只需查两个节点进行遍历就行，而B树需要获取所有节点，所以B+树在范围查询上效率更高。")]),_._v(" "),v("p",[_._v("3.在数据检索方面，由于所有的数据都存储在叶子节点，所以B+树的IO次数会更加稳定。")]),_._v(" "),v("p",[_._v("4.因为叶子节点存储所有数据，所以B+树的全局扫描能力更强一些，因为他只需要扫描叶子节点。但是B树需要遍历整个树。")]),_._v(" "),v("h4",{attrs:{id:"联合索引的最左匹配原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#联合索引的最左匹配原则"}},[_._v("#")]),_._v(" 联合索引的最左匹配原则")]),_._v(" "),v("p",[_._v("最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。")]),_._v(" "),v("h3",{attrs:{id:"_3-视图、存储过程、函数和触发器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-视图、存储过程、函数和触发器"}},[_._v("#")]),_._v(" 3. 视图、存储过程、函数和触发器")]),_._v(" "),v("p",[_._v("视图是一种虚拟表，行和列数据来定义视图的查询中使用的表，并且是在使用视图时动态生成的。")]),_._v(" "),v("p",[_._v("存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合，可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有效的。")]),_._v(" "),v("p",[_._v("触发器是在满足条件时触发并执行触发器的语句集合。")]),_._v(" "),v("h3",{attrs:{id:"_5-sql优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-sql优化"}},[_._v("#")]),_._v(" 5.SQL优化")]),_._v(" "),v("p",[_._v("（1）首先分析低效SQL的执行计划")]),_._v(" "),v("p",[_._v("（2）常用SQL的优化")]),_._v(" "),v("h3",{attrs:{id:"_6-事物控制和mysql锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-事物控制和mysql锁"}},[_._v("#")]),_._v(" 6.事物控制和Mysql锁")]),_._v(" "),v("p",[_._v("（1）事务的ACID特性：原子性、一致性、隔离性、持久性。")]),_._v(" "),v("p",[_._v("（2）并发事务带来的问题：更新丢失、脏读、不可重复读、幻读。")]),_._v(" "),v("p",[_._v("（3）事务的隔离级别：未提交读、已提交读、可重复读、可序列化。")]),_._v(" "),v("p",[_._v("（4）InnoDB实现了以下两种类型的行锁：共享锁（s）和排它锁（x）")]),_._v(" "),v("h3",{attrs:{id:"_7-优化数据库表的设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-优化数据库表的设计"}},[_._v("#")]),_._v(" 7.优化数据库表的设计")]),_._v(" "),v("p",[_._v("（1）优化表的数据类型")]),_._v(" "),v("p",[_._v("（2）分库分表")]),_._v(" "),v("p",[_._v("（3）逆规范化")]),_._v(" "),v("hr")])}),[],!1,null,null,null);v.default=a.exports}}]);